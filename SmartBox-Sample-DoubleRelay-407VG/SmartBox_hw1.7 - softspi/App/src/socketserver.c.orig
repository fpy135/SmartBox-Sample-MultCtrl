#include <lwip/sockets.h>
#include <lwip/err.h>
#include <lwip/sys.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>								//包含需要的所有头文件，（实现socket和标准输入输出）
#include "socketserver.h"
#include "usart.h"
#include "Protocol.h"
#include "Led_App.h"


QueueHandle_t TCP_SEND_Queue;
int sock_fd;								//服务器的 socked 

uint8_t tcp_server_recvbuf[TCP_BUFF_SIZE];					//定义数据处理Buff大小为300（为100也无所谓，只要大于等于100就好）
uint8_t tcp_server_sendbuf[TCP_BUFF_SIZE];

BaseType_t Tcp_TaskID;
xTaskHandle pvCreatedTask_Tcp;

uint32_t Device_ID = 0;		//设备ID
uint8_t Sn = 0;				//数据包流水号


static void tcp_server_thread(void *p_arg)		//定义TCP服务器线程
{
	struct sockaddr_in server_addr;				//服务器地址
	struct sockaddr_in conn_addr;				//连接地址
	int sock_conn;								// 请求的 socked 
	socklen_t addr_len;							// 地址长度 
	int err;
	int length;
	int num;
//	int count = 0;
	
	sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);		//建立一个新的socket连接	
	memset(&server_addr, 0, sizeof(server_addr));				//将服务器地址清空
	server_addr.sin_family = AF_INET;							//地址家族
	server_addr.sin_addr.s_addr =htonl(INADDR_ANY);				//注意转化为网络字节序
	server_addr.sin_port = htons(SERVER_PORT);					//使用SERVER_PORT指定为程序头设定的端口号
	
	err = bind(sock_fd, (struct sockaddr *)&server_addr, sizeof(server_addr));	//建立绑定
	if (err < 0)															    //如果绑定失败则关闭套接字
	{
			closesocket(sock_fd); 												//关闭套接字
	}
	
	err = listen(sock_fd, 1);									//监听连接请求
	if (err < 0) 												//如果监听失败则关闭套接字
	{
			closesocket(sock_fd); 								//关闭套接字
	}
		addr_len = sizeof(struct sockaddr_in);					//将链接地址赋值给addr_len
	
		sock_conn = accept(sock_fd, (struct sockaddr *)&conn_addr, &addr_len);	//对监听到的请求进行连接，状态赋值给sock_conn
	
		if(sock_conn<0)											//状态小于0代表连接故障，此时关闭套接字
		{
			closesocket(sock_fd);
		}
		else send(sock_conn, "connect success!\n\r", 20, 0);	//连接成功则发送“connect success!”给客户端
	
	while (1) 
	{
		memset(tcp_server_recvbuf, 0, TCP_BUFF_SIZE);			//清空接收Buff
		
		length = recv(sock_conn, (unsigned int *)tcp_server_recvbuf, TCP_BUFF_SIZE, 0);	//将收到的数据放到接收Buff
		
		if(tcp_server_recvbuf[0]=='L'&tcp_server_recvbuf[1]=='E'&tcp_server_recvbuf[2]=='D'&
									tcp_server_recvbuf[3]=='0'&tcp_server_recvbuf[4]=='O'&tcp_server_recvbuf[5]=='N')
									//判断收到的数据是否为LED1ON
								{
								HAL_GPIO_WritePin(GPIOC,  GPIO_PIN_13, GPIO_PIN_RESET);		//打开LED0
								send(sock_conn, "LED0已打开\n",strlen("LED0已打开\n"), 1);	//回复客户端LED1已打开

								}
								
								if(tcp_server_recvbuf[0]=='L'&tcp_server_recvbuf[1]=='E'&tcp_server_recvbuf[2]=='D'&
									tcp_server_recvbuf[3]=='0'&tcp_server_recvbuf[4]=='O'&tcp_server_recvbuf[5]=='F'&tcp_server_recvbuf[6]=='F')
									//判断收到的数据是否为LED1OFF
								{
								HAL_GPIO_WritePin(GPIOC,  GPIO_PIN_13, GPIO_PIN_SET);		//关闭LED1
								send(sock_conn, "LED0已关闭\n",strlen("LED0已关闭\n"), 1);	//回复客户端LED1已关闭
								}
								/*LED0使用指令*/
								if(tcp_server_recvbuf[0]=='U'&tcp_server_recvbuf[1]=='S'&tcp_server_recvbuf[2]=='B'&
									tcp_server_recvbuf[3]=='0'&tcp_server_recvbuf[4]=='O'&tcp_server_recvbuf[5]=='N')	
									//判断收到的数据是否为LED0ON
								{
								HAL_GPIO_WritePin(GPIOH,  GPIO_PIN_11, GPIO_PIN_SET);		//打开LED0
								send(sock_conn, "LED0已打开\n",strlen("USB0已打开\n"), 1);	//回复客户端LED0已打开
								}
								
								if(tcp_server_recvbuf[0]=='U'&tcp_server_recvbuf[1]=='S'&tcp_server_recvbuf[2]=='B'&
									tcp_server_recvbuf[3]=='0'&tcp_server_recvbuf[4]=='O'&tcp_server_recvbuf[5]=='F'&tcp_server_recvbuf[6]=='F')
									//判断收到的数据是否为LED0OFF
								{
								HAL_GPIO_WritePin(GPIOH,  GPIO_PIN_11, GPIO_PIN_RESET);		//关闭LED0
								send(sock_conn, "LED0已关闭\n",strlen("USB0已关闭\n"), 1);	//回复客户端LED0已关闭
								}
	osDelay(10);
	}
}

void tcp_server_init(void)	//TCP服务器初始化
{
	sys_thread_new("tcp_server_thread",  tcp_server_thread, NULL, DEFAULT_THREAD_STACKSIZE, DEFAULT_THREAD_PRIO - 1);
		//进入TCP服务器线程
}

void socket_SendData(uint8_t sn, uint32_t id, uint8_t cmd,uint16_t len,uint8_t *senddata)
{
	uint8_t *pbuf;
	
	pbuf = Protocol_Pack(sn,id,cmd,len,(uint8_t *)senddata);
	#if TCP_Data_Printf
		printf("\r\n TCP send:");
		myprintf((uint8_t *)pbuf, 8+len+2);
	#endif

	send(sock_fd, (char *)pbuf, 8+len+2, 0);		//8为负载以前的固定数据的数据长度+负载数据长度+crc
}

void socket_RecvDate_Process(uint8_t *recvdata)
{
	if(recvdata[0] == 0xAA)
	{
//		if()		//ID校验
		uint16_t crc_tmp1,crc_tmp2;
		uint8_t datalen = 8+recvdata[7]+2;		//8为负载以前的固定数据的数据长度+负载数据长度+crc
		crc_tmp2 = CRC16_Calc(recvdata,datalen-2);	
		crc_tmp1 = recvdata[datalen-1]<<8 | recvdata[datalen-2];
		if(crc_tmp2 == crc_tmp1)
		{
			#if TCP_Data_Printf
				printf("\r\n TCP recever:");
				myprintf(recvdata,datalen);
			#endif
			if(recvdata[6] == LedControl_Cmd)		//开关灯命令字
			{
				LedStatus = tcp_server_recvbuf[8];		//LED开关状态更新
				if(LedStatus == LEDON)
				{
					HAL_GPIO_WritePin(GPIOI, AC_REL_Pin, GPIO_PIN_SET);
					Led_Switch_Brightness(tcp_server_recvbuf[9]);	//LED亮度目标百分比调整
				}
				else if(LedStatus == LEDOFF)
				{
					Led_Switch_Brightness(0);	//LED亮度目标百分比调整
					HAL_GPIO_WritePin(GPIOI, AC_REL_Pin, GPIO_PIN_RESET);
				}
				socket_SendData(Sn,Device_ID,LedControlBack_Cmd,4,&recvdata[8]);
			}
		}
	}
}

static void tcp_client_thread(void *p_arg)
{
	struct sockaddr_in server_addr;
	char msg[] = "hello, you are connected!\n";
	uint8_t *pbuf;
	int recvFlag = MSG_DONTWAIT;	
	int8_t connect_info;
//	uint8_t *msgdata = NULL;	
//	TCP_SEND_Queue = xQueueCreate( TCP_SEND_QUEUE_LENGTH, sizeof( struct AMessage * ) );

	TCP_SEND_Queue = xQueueCreate( TCP_SEND_QUEUE_LENGTH, 15 );
	
//	int keepAlive = 1; // 开启keepalive属性
//	int keepIdle = 60; // 如该连接在60秒内没有任何数据往来,则进行探测
//	int keepInterval = 5; // 探测时发包的时间间隔为5 秒
//	int keepCount = 3; // 探测尝试的次数.如果第1次探测包就收到响应了,则后2次的不再发.

	
	sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	memset(&server_addr, 0, sizeof(server_addr));
	server_addr.sin_family = AF_INET;
	server_addr.sin_addr.s_addr = inet_addr(SERVER_IP);
	server_addr.sin_port = htons(SERVER_PORT);
	connect(sock_fd, (struct sockaddr *)&server_addr, sizeof(struct sockaddr));

	while(1)
	{
		connect_info = recv(sock_fd,tcp_server_recvbuf,TCP_BUFF_SIZE,recvFlag);
		if(connect_info > 0)		//获得到数据
		{
			/************开关灯代码段************/
			socket_RecvDate_Process(tcp_server_recvbuf);
			Led_Switch_Brightness(tcp_server_recvbuf[0]);
//			send(sock_fd, (char *)&tcp_server_recvbuf, 14, 0);
			memset(tcp_server_recvbuf,0,14);
		}
		else if((connect_info == -1) && (errno == EWOULDBLOCK))  // 没收到数据
		{
			;
		}
		else
		{
			{
				printf("与服务器断开连接\r\n");
				closesocket(sock_fd);
				sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
				memset(&server_addr, 0, sizeof(server_addr));
				server_addr.sin_family = AF_INET;
				server_addr.sin_addr.s_addr = inet_addr(SERVER_IP);
				server_addr.sin_port = htons(SERVER_PORT);
				connect(sock_fd, (struct sockaddr *)&server_addr, sizeof(struct sockaddr));
			}
		}
		if(xQueuePeek(TCP_SEND_Queue,tcp_server_sendbuf, ( TickType_t )100) == pdPASS)	//接收队列消息
		{
			socket_SendData(Sn,Device_ID,Heart_Cmd,tcp_server_sendbuf[0],(uint8_t *)&tcp_server_sendbuf[1]);
			if(tcp_server_sendbuf[0] == 14)		//负载数据长度为12的情况 	环境监测
			{
//				pbuf = Protocol_Pack(1,22,Heart_Cmd,tcp_server_sendbuf[0],(uint8_t *)&tcp_server_sendbuf[1]);
//				myprintf((uint8_t *)pbuf, 8+tcp_server_sendbuf[0]+2);
//				send(sock_fd, (char *)pbuf, 8+tcp_server_sendbuf[0]+2, 0);
//				*pbuf = 0x02;
//				printf("send 2\r\n");
//				send(sock_fd, (char *)pbuf, 1, 0);
			}
			else if(tcp_server_sendbuf[0] == 4)		//负载数据长度为4的情况		开关灯信号
			{
//				socket_SendData(1,22,Heart_Cmd,tcp_server_sendbuf[0],(uint8_t *)&tcp_server_sendbuf[1]);
//				pbuf = Protocol_Pack(1,22,0x01,tcp_server_sendbuf[0],(uint8_t *)&tcp_server_sendbuf[1]);
//				myprintf((uint8_t *)pbuf, 8+tcp_server_sendbuf[0]+2);
//				send(sock_fd, (char *)pbuf, 8+tcp_server_sendbuf[0]+2, 0);
			}
			xQueueReceive(TCP_SEND_Queue, (void *)&tcp_server_sendbuf, ( TickType_t )0);
		}
	}
}

void CreatTCPTask(void)	//TCP客户端初始化
{
		//进入TCP客户端线程
//	sys_thread_new("tcp_client_thread",  tcp_client_thread, NULL, DEFAULT_THREAD_STACKSIZE, DEFAULT_THREAD_PRIO - 1);
	Tcp_TaskID = xTaskCreate(tcp_client_thread, "TCP", TCP_StkSIZE, NULL, TCP_TaskPrio, &pvCreatedTask_Tcp);
	if(pdPASS != Tcp_TaskID)
	{
		printf("\r\nTcp_Task creat error");
		while(1);
	}
}
